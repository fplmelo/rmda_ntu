[
  {
    "objectID": "assessment.html",
    "href": "assessment.html",
    "title": "Assessment Brief 2025-26",
    "section": "",
    "text": "This Module covers the following courses:\n\nMSc/MRes Applied Ecology & Geospatial Techniques\nMSc/MRes Biodiversity Conservation\nMSc/MRes Endangered Species Recovery & Conservation\nMSc/MRes Equine Performance, Health & Welfare MSc/MRes Smart Agriculture"
  },
  {
    "objectID": "assessment.html#summative-assessment-brief",
    "href": "assessment.html#summative-assessment-brief",
    "title": "Assessment Brief 2025-26",
    "section": "",
    "text": "This Module covers the following courses:\n\nMSc/MRes Applied Ecology & Geospatial Techniques\nMSc/MRes Biodiversity Conservation\nMSc/MRes Endangered Species Recovery & Conservation\nMSc/MRes Equine Performance, Health & Welfare MSc/MRes Smart Agriculture"
  },
  {
    "objectID": "assessment.html#formative-assessments",
    "href": "assessment.html#formative-assessments",
    "title": "Assessment Brief 2025-26",
    "section": "Formative Assessments",
    "text": "Formative Assessments\nYour formative opportunities are related to the development of your workbook and sharing of this development with module leader and colleagues.\n\n\n\n\n\n\nShare your Workbook\n\n\n\nYou must not be shy or embarrassed to share your workbook. Nobody will judge you. We are all learning!"
  },
  {
    "objectID": "assessment.html#type-of-assessment",
    "href": "assessment.html#type-of-assessment",
    "title": "Assessment Brief 2025-26",
    "section": "Type of Assessment",
    "text": "Type of Assessment\nYour Summative is to produce an “article-like” dynamic document containing an analytical workflow for a given dataset where critically interpret the results and draw your conclusions.\n\nStep 1 - Context\nYou will be given a context of a scientific problem. This context will introduce you to a real-world problem that is going to be used as a background for the data that you are going to analyse.\n\n\nStep 2 - The dataset\nYou will have access to a pre-built dataset in a .csv format that will contain all the data and metadata needed for your analyses. The data is the same for everyone and I am not providing data on your specific subject of studies.\n\n\nStep 3 - Your Workbook\nYou are going to work on the assessment using your Quarto workbook constructed over the course of the whole module. This is going to be your submission. I’ll collect your exams using a NOW Dropbox where you can paste the link to your published workbook.\n\n\n\n\n\n\nNote\n\n\n\nThe dataset and context description for the Summative exam will be shared by the end of the module sessions (probably in the last week of classes)."
  },
  {
    "objectID": "assessment.html#transferable-skills-developed-in-this-assessment",
    "href": "assessment.html#transferable-skills-developed-in-this-assessment",
    "title": "Assessment Brief 2025-26",
    "section": "Transferable skills developed in this assessment",
    "text": "Transferable skills developed in this assessment\n\nAnalytical workflow\n\nCreate and attach to an analytical workflow that is reproducible\nGenerate good quality graphs and tables\nComment and understand R code\nIdentify core results within a set of exploratory analyses.\nInterpret and generate conclusions based on data analysed"
  },
  {
    "objectID": "assessment.html#specific-tasks",
    "href": "assessment.html#specific-tasks",
    "title": "Assessment Brief 2025-26",
    "section": "Specific tasks",
    "text": "Specific tasks\n\nDesign an experimental design\nDescribe methods for reproducibility\nCreate a analytical workflow\nComment on the R codes in your workbook"
  },
  {
    "objectID": "assessment.html#assessment-guidance",
    "href": "assessment.html#assessment-guidance",
    "title": "Assessment Brief 2025-26",
    "section": "Assessment Guidance",
    "text": "Assessment Guidance\n\nAnalytical workflow (15%)\nR code commented (15%)\nExploratory analysis (20%)\nQuality graphs and tables (25%)\nInterpretation of results (25%)"
  },
  {
    "objectID": "assessment.html#further-information",
    "href": "assessment.html#further-information",
    "title": "Assessment Brief 2025-26",
    "section": "Further information",
    "text": "Further information\n\nExtenuating circumstances"
  },
  {
    "objectID": "assessment.html#grading-matrix",
    "href": "assessment.html#grading-matrix",
    "title": "Assessment Brief 2025-26",
    "section": "Grading Matrix",
    "text": "Grading Matrix\n\n\n\n\n\n\n\n\n\n\n\n\nCriteria\nFail\nLow | Mid\nMarginal Fail\nPass\nLow | Mid | High\nCommendation\nLow | Mid | High\nDistinction\nLow | Mid |High\nDistinction\nExceptional\n\n\n\n\nAnalytical workflow\nNo clear analytical workflow\nWorkflow not easy to find; mixed analytical approach in search for any significant p-value\nWorkflow relatively reasonable but with excess of flaw analyses and lack of a logic sequence that goes from 1) preparation; 2) data wrangling; 3) Exploratory analyses; 4) Core analyses\nClear workflow but hard to reproduce because crucial steps were either omitted or non commented.\nVery good workflow with clear guidance for reproducibility\nHigh quality workflow, fully reproducible and extensively commented\n\n\nR code commented\nLittle to no comments on coding\nComments provided but non meaningful for crucial steps\nCodes mostly commented but crucial steps are not udnerstood\nCodes mostly commented and helping reproducibility.\nCodes fully commented but not excessively, avoiding visual pollution\nCodes fully commented and not affecting visual inspection of the script and allows full reproducibility and explanation in key steps\n\n\nExploratory analysis\nNo exploratory analyses done\nInsufficient exploratory analyses\nEnough exploratory analyses but not commented or justified\nGood exploratory analyses but poorly commented and little justified\nVery good exploratory analyses, commented and justified\nWorld-class and fully justified exploratory approach to data\n\n\nQuality graphs and tables\nPoor graphs, lacking crucial elements such as axis title and captions\nPoor graphs and tables with some elements present but poorly explained while other elements are missig\nGraphs and tables present with most elements, but some missing components preclude full understanding of the info presented\nGraphs and tables of acceptable quality with all elements present but not clearly descripted\nGood quality graphs and tables that could be accepted for publication in any serious scientific journal\nOutstading graphs and tables with graphical abstracts and schematic figures. All elements present and fully explained.\n\n\nInterpretation of results\nPoor or inexistant critical interpretation of the results found\nDeficient interpretation of the results and misuse of statistical concepts and wrong translation of tests and graphs\nResults are just reported with no critical interpretation or further discussion\nResults correctly reported and critically interpreted but excessive speculation is present\nResults are fully reported in a correct manner with string attachment to the proposed workflow and are discussed without much speculation\nExcellent interpretation, creative and fully connected with scientific hypotheses"
  },
  {
    "objectID": "sessions/index.html",
    "href": "sessions/index.html",
    "title": "Content",
    "section": "",
    "text": "Week 1 - Introduction to RMDA\n\n\n\n\n\n\nFelipe Melo\n\n\nApr 6, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 2 - Data Wrangling\n\n\n\n\n\n\nFelipe Melo\n\n\nApr 7, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "sessions/week1/1-intro.html",
    "href": "sessions/week1/1-intro.html",
    "title": "Week 1 - Introduction to RMDA",
    "section": "",
    "text": "Today you are going to understand how this modules works."
  },
  {
    "objectID": "sessions/week1/1-intro.html#slides",
    "href": "sessions/week1/1-intro.html#slides",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Slides",
    "text": "Slides\n    View slides in full screen"
  },
  {
    "objectID": "sessions/week1/1-intro.html#videos",
    "href": "sessions/week1/1-intro.html#videos",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Videos",
    "text": "Videos"
  },
  {
    "objectID": "sessions/week1/1-intro.html#exercise-1---create-your-workbook",
    "href": "sessions/week1/1-intro.html#exercise-1---create-your-workbook",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Exercise 1 - Create your workbook",
    "text": "Exercise 1 - Create your workbook"
  },
  {
    "objectID": "sessions/week1/1-intro.html#introduction",
    "href": "sessions/week1/1-intro.html#introduction",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Introduction",
    "text": "Introduction\nQuarto is a powerful tool for creating dynamic documents and websites. This tutorial will guide you through the process of creating a simple webpage using Quarto."
  },
  {
    "objectID": "sessions/week1/1-intro.html#prerequisites",
    "href": "sessions/week1/1-intro.html#prerequisites",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore you begin, make sure you have the following installed:\n\nQuarto: You can download and install Quarto from quarto.org.\nRstudio: However, any text editor will work, such as VS Code, Sublime Text, or Notepad++.\n\n\nStep 1: Create a New Quarto Document\n\nOpen your terminal or command prompt.\nNavigate to the directory where you want to create your webpage.\nRun the following command to create a new Quarto document:\nquarto create webpage.qmd\nThis command creates a file named webpage.qmd.\n\n\n\nStep 2: Edit the Quarto Document\n\nOpen webpage.qmd in your text editor.\nYou’ll see some default content, including a title and some example text.\nModify the content to create your webpage. For example:\n---\ntitle: \"My First Quarto Webpage\"\nformat: html\n---\n\n## Welcome!\n\nThis is my first webpage created with Quarto.\n\nHere's a simple list:\n\n* Item 1\n* Item 2\n* Item 3\n\nYou can also include code blocks:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(\"Hello, Quarto!\")\n\n[1] \"Hello, Quarto!\"\n\n:::\nAnd mathematical equations:\n\\[\nE = mc^2\n\\]\nYou can add images too:\n\nknitr::include_graphics(\"https://quarto.org/quarto.png\")\n\n\n\n\n\n\n\n\n```\nExplanation of the code:\n\n--- title: \"My First Quarto Webpage\" format: html --- : This is the YAML header, which sets the title of your webpage and specifies the output format (HTML in this case).\n## Welcome! : This is a level 2 heading.\n* Item 1 : This creates a bulleted list.\n```{r}: This begins a R code block.\n$$E = mc^2$$: This inserts a LaTeX equation.\n```{r}: This begins an R code block.\nknitr::include_graphics(\"https://quarto.org/quarto.png\"): This includes an image from a URL.\n\n\n\n\nStep 3: Render the Webpage\n\nIn your terminal or command prompt, navigate to the directory containing webpage.qmd.\nRun the following command to render the webpage:\nquarto render webpage.qmd\nThis command will create an HTML file named webpage.html in the same directory.\n\n\n\nStep 4: View the Webpage\n\nOpen webpage.html in your web browser.\nYou should see your webpage with the content you created."
  },
  {
    "objectID": "sessions/week1/1-intro.html#adding-more-content",
    "href": "sessions/week1/1-intro.html#adding-more-content",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Adding more content",
    "text": "Adding more content\nYou can add more content to your webpage by editing webpage.qmd. Quarto supports various types of content, including:\n\nHeadings: Use #, ##, ###, etc. for different heading levels.\nParagraphs: Just type your text.\nLists: Use * or - for unordered lists, and 1., 2., etc. for ordered lists.\nCode Blocks: Use ```{language} to insert code blocks.\nMathematical Equations: Use $$ for LaTeX equations.\nImages: Use ![alt text](path/to/image.png) or {r} knitr::include_graphics(\"path/to/image.png\").\nLinks: Use [link text](url).\nTables: Use Markdown table syntax."
  },
  {
    "objectID": "sessions/week1/1-intro.html#further-exploration",
    "href": "sessions/week1/1-intro.html#further-exploration",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Further Exploration",
    "text": "Further Exploration\n\nExplore the Quarto documentation for more advanced features: quarto.org.\nExperiment with different output formats, such as PDF or Word.\nLearn about Quarto projects for creating multi-page websites.\nLook into adding CSS and Javascript for styling and interactivity."
  },
  {
    "objectID": "sessions/week1/1-intro.html#publishing-to-quarto-pub",
    "href": "sessions/week1/1-intro.html#publishing-to-quarto-pub",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Publishing to Quarto Pub",
    "text": "Publishing to Quarto Pub\nKnow how to publish your Quarto webpage to Quarto Pub, making it accessible online."
  },
  {
    "objectID": "sessions/week1/1-intro.html#prerequisites-1",
    "href": "sessions/week1/1-intro.html#prerequisites-1",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nAll the prerequisites from the previous tutorial.\nA Quarto Pub account. You can create one at quarto.pub.\n\n\nStep 1: Create a Quarto Webpage (If you haven’t already)\nIf you haven’t already created a Quarto webpage, follow the steps in the previous tutorial to create webpage.qmd and render it into webpage.html.\n\n\nStep 2: Initialize Quarto Pub\n\nOpen your terminal or command prompt.\nNavigate to the directory containing webpage.qmd.\nRun the following command to initialize Quarto Pub:\nquarto publish quarto-pub\nThis command will prompt you to log in to your Quarto Pub account. Follow the instructions to authenticate.\n\n\n\nStep 3: Publish Your Webpage\n\nAfter successful authentication, Quarto will detect the webpage.html file and ask you if you want to publish it.\nConfirm that you want to publish the webpage.\nQuarto will upload your webpage to Quarto Pub.\nYou’ll receive a URL where your webpage is hosted.\n\n\n\nStep 4: View Your Published Webpage\n\nOpen the URL provided by Quarto in your web browser.\nYou should see your webpage hosted on Quarto Pub.\n\n\n\nStep 5: Updating your published page.\nIf you edit the webpage.qmd file, you will need to re-render the html file, and then republish.\n\nEdit webpage.qmd with your text editor.\nRender the html file again.\nquarto render webpage.qmd\nRepublish the webpage.\nquarto publish quarto-pub\nQuarto Pub will update the existing webpage with the new content."
  },
  {
    "objectID": "sessions/week1/1-intro.html#important-considerations",
    "href": "sessions/week1/1-intro.html#important-considerations",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Important Considerations",
    "text": "Important Considerations\n\nFile Organization: For more complex websites, consider creating a Quarto project. This will help you organize your files and manage your website more effectively.\nCustom Domains: Quarto Pub allows you to use custom domains for your websites. Refer to the Quarto Pub documentation for instructions.\nSecurity: Be mindful of the content you publish online. Avoid sharing sensitive information.\nQuarto Pub Limitations: Quarto Pub has some limitations, especially for large or complex websites. For more advanced hosting options, consider using other platforms like Netlify or GitHub Pages.\nFree tier limitations: The free tier of Quarto Pub has some limitations, regarding the number of deployments, and storage. Refer to the Quarto Pub documentation for the most up to date limitations."
  },
  {
    "objectID": "sessions/week1/1-intro.html#further-exploration-1",
    "href": "sessions/week1/1-intro.html#further-exploration-1",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Further Exploration",
    "text": "Further Exploration\n\nExplore the Quarto Pub documentation for more advanced features: quarto.pub.\nLearn about Quarto projects for creating multi-page websites.\nExperiment with different Quarto Pub settings and options."
  },
  {
    "objectID": "sessions/week1/1-intro.html#exercise-1",
    "href": "sessions/week1/1-intro.html#exercise-1",
    "title": "Week 1 - Introduction to RMDA",
    "section": "Exercise",
    "text": "Exercise\nNow create your own quarto workbook:\n1 - Download the zip file of the project\n2- Tweak the *qmd file as you wish\n3 - Publish your workbook\n4 - Submit to the link to NOW dropbox folder"
  },
  {
    "objectID": "get-started/3-syntax.html",
    "href": "get-started/3-syntax.html",
    "title": "R Syntax and Data Structures",
    "section": "",
    "text": "Approximate time: 70 min"
  },
  {
    "objectID": "get-started/3-syntax.html#learning-objectives",
    "href": "get-started/3-syntax.html#learning-objectives",
    "title": "R Syntax and Data Structures",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe frequently-used data types in R.\nConstruct data structures to store data."
  },
  {
    "objectID": "get-started/3-syntax.html#the-r-syntax",
    "href": "get-started/3-syntax.html#the-r-syntax",
    "title": "R Syntax and Data Structures",
    "section": "The R syntax",
    "text": "The R syntax\nNow that we know how to talk with R via the script editor or the console, we want to use R for something more than adding numbers. To do this, we need to know more about the R syntax.\nBelow is an example script highlighting the many different “parts of speech” for R (syntax):\n\nthe comments # and how they are used to document function and its content\nvariables and functions\n\nthe assignment operator &lt;-\n\nthe = for arguments in functions\n\nNOTE: indentation and consistency in spacing is used to improve clarity and legibility\n\nExample script\n## DO NOT RUN\n\n# Load libraries\nlibrary(Biobase)\nlibrary(limma)\nlibrary(ggplot2)\n\n# Setup directory variables\nbaseDir &lt;- getwd()\ndataDir &lt;- file.path(baseDir, \"data\")\nmetaDir &lt;- file.path(baseDir, \"meta\")\nresultsDir &lt;- file.path(baseDir, \"results\")\n\n# Load data\nmeta &lt;- read.delim(file.path(metaDir, '2015-1018_sample_key.csv'), header=T, sep=\"\\t\", row.names=1)"
  },
  {
    "objectID": "get-started/3-syntax.html#assignment-operator",
    "href": "get-started/3-syntax.html#assignment-operator",
    "title": "R Syntax and Data Structures",
    "section": "Assignment operator",
    "text": "Assignment operator\nTo do useful and interesting things in R, we need to assign values to variables using the assignment operator, &lt;-. For example, we can use the assignment operator to assign the value of 3 to x by executing:\nx &lt;- 3\nThe assignment operator (&lt;-) assigns values on the right to variables on the left.\nIn RStudio, typing Alt + - (push Alt at the same time as the - key) will write &lt;- in a single keystroke.\n## Variables\nA variable is a symbolic name for (or reference to) information. Variables in computer programming are analogous to “buckets”, where information can be maintained and referenced. On the outside of the bucket is a name. When referring to the bucket, we use the name of the bucket, not the data stored in the bucket.\nIn the example above, we created a variable or a ‘bucket’ called x. Inside we put a value, 3.\nLet’s create another variable called y and give it a value of 5.\ny &lt;- 5\nWhen assigning a value to an variable, R does not print anything to the console. You can force to print the value by using parentheses or by typing the variable name.\ny\nYou can also view information on the variable by looking in your Environment window in the upper right-hand corner of the RStudio interface.\n\n\n\nViewing your environment\n\n\nNow we can reference these buckets by name to perform mathematical operations on the values contained within. What do you get in the console for the following operation:\nx + y\nTry assigning the results of this operation to another variable called number.\nnumber &lt;- x + y\n\nExercise\n\nTry changing the value of the variable x to 5. What happens to number?\nNow try changing the value of variable y to contain the value 10. What do you need to do, to update the variable number?\n\n\n\nTips on variable names\nVariables can be given almost any name, such as x, current_temperature, or subject_id. However, there are some rules / suggestions you should keep in mind:\n\nAvoid names starting with a number (2x is not valid but x2 is)\nKeep in mind that R is case sensitive (e.g., genome_length is different from Genome_length)\nMake your names explicit and not too long.\nBe consistent with the styling of your code (where you put spaces, how you name variable, etc.). In R, two popular style guides are Hadley Wickham’s style guide and Google’s.\nAvoid names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, T, mean, data) as variable names. When in doubt check the help to see if the name is already in use.\nAvoid dots (.) within a variable name as in my.dataset. There are many functions in R with dots in their names for historical reasons, but because dots have aspeci al meaning in R (for methods) and other programming languages, it’s best to avoid them. - Use nouns for object names and verbs for function names\n                                                                                                      ## Data Types\n\n                                                                                                                                                                                                       Variables can contain values of specific types within R. The six **data types** that R uses include: \n\n                                                                                                                                                                                                         * `\"numeric\"` for any numerical value \n                                                                                                                                                                                                       * `\"character\"` for text values, denoted by using quotes (\"\") around value   \n                                                                                                                                                                                                       * `\"integer\"` for integer numbers (e.g., `2L`, the `L` indicates to R that it's an integer)\n\"logical\" for TRUE and FALSE (the boolean data type)\n\"complex\" to represent complex numbers with real and imaginary parts (e.g., 1+4i) and that’s all we’re going to say about them\n\"raw\" that we won’t discuss further\n                                                                                                                                                                                                                                          The table below provides examples of each of the commonly used data types:\n\n                                                                                                                                                                                                                                            | Data Type  | Examples|\n                                                                                                                                                                                                                                            | -----------:|:-------------------------------:|\n                                                                                                                                                                                                                                            | Numeric:  | 1, 1.5, 20, pi|\n                                                                                                                                                                                                                                            | Character:  | “anytext”, “5”, “TRUE”|\n                                                                                                                                                                                                                                            | Integer:  | 2L, 500L, -17L|\n                                                                                                                                                                                                                                            | Logical:  | TRUE, FALSE, T, F|\n\n                                                                                                                                                                                                                                            ## Data Structures\n\n                                                                                                                                                                                                                                            We know that variables are like buckets, and so far we have seen that bucket filled with a single value. Even when `number` was created, the result of the mathematical operation was a single value. **Variables can store more than just a single value, they can store a multitude of different data structures.** These include, but are not limited to, vectors (`c`), factors (`factor`), matrices (`matrix`), data frames (`data.frame`) and lists (`list`).\n\n\n                                                                                                                                                                                                                                          ### Vectors\n\n                                                                                                                                                                                                                                          A vector is the most common and basic data structure in R, and is pretty much the workhorse of R. It's basically just a collection of values, mainly either numbers,\n\n\n\n\nnumeric vector\n\n\nor characters,\n\n\n\ncharacter vector\n\n\nor logical values,\n\n\n\nlogical vector\n\n\nNote that all values in a vector must be of the same data type. If you try to create a vector with more than a single data type, R will try to coerce it into a single data type.\nFor example, if you were to try to create the following vector:\n\n\n\nmixed vector\n\n\nR will coerce it into:\n\nThe analogy for a vector is that your bucket now has different compartments; these compartments in a vector are called elements.\nEach element contains a single value, and there is no limit to how many elements you can have. A vector is assigned to a single variable, because regardless of how many elements it contains, in the end it is still a single entity (bucket).\nLet’s create a vector of genome lengths and assign it to a variable called glengths.\n                                                                                                                                                                                                                                            Each element of this vector contains a single numeric value, and three values will be combined together into a vector using `c()` (the combine function). All of the values are put within the parentheses and separated with a comma.\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ```r\n                                                                                                                                                                                                                                            glengths &lt;- c(4.6, 3000, 50000)\n                                                                                                                                                                                                                                            glengths\n                                                                                                                                                                                                                                            ```\n                                                                                                                                                                                                                                            *Note your environment shows the `glengths` variable is numeric and tells you the `glengths` vector starts at element 1 and ends at element 3 (i.e. your vector contains 3 values).*\n                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                              A vector can also contain characters. Create another vector called `species` with three elements, where each element corresponds with the genome sizes vector (in Mb).\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ```r\n                                                                                                                                                                                                                                            species &lt;- c(\"ecoli\", \"human\", \"corn\")\n                                                                                                                                                                                                                                            species\n                                                                                                                                                                                                                                            ```\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ### Factors\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            A **factor** is a special type of vector that is used to **store categorical data**. Each unique category is referred to as a **factor level** (i.e. category = level). Factors are built on top of integer vectors such that each **factor level** is assigned an **integer value**, creating value-label pairs. \n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ![factors](../img/factors_sm.png)\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            Let's create a factor vector and explore a bit more.  We'll start by creating a character vector describing three different levels of expression:\n                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                              ```r\n                                                                                                                                                                                                                                            expression &lt;- c(\"low\", \"high\", \"medium\", \"high\", \"low\", \"medium\", \"high\")\n                                                                                                                                                                                                                                            ```\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            Now we can convert this character vector into a *factor* using the `factor()` function:\n                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                              ```r\n                                                                                                                                                                                                                                            expression &lt;- factor(expression)\n                                                                                                                                                                                                                                            ```\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            So, what exactly happened when we applied the `factor()` function? \n                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                              ![factor_new](../img/factors_new.png)\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            The expression vector is categorical, in that all the values in the vector belong to a set of categories; in this case, the categories are `low`, `medium`, and `high`. By turning the expression vector into a factor, the **categories are assigned integers alphabetically**, with high=1, low=2, medium=3. This in effect assigns the different factor levels. You can view the newly created factor variable and the levels in the **Environment** window.\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ![Factor variables in environment](../img/factors.png)\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ### Matrix\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            A `matrix` in R is a collection of vectors of **same length and identical datatype**. Vectors can be combined as columns in the matrix or by row, to create a 2-dimensional structure.\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ![matrix](../img/matrix.png)\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            Matrices are used commonly as part of the mathematical machinery of statistics. They are usually of numeric datatype and used in computational algorithms to serve as a checkpoint. For example, if input data is not of identical data type (numeric, character, etc.), the `matrix()` function will throw an error and stop any downstream code execution.\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            ### Data Frame\n                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                            A `data.frame` is the _de facto_ data structure for most tabular data and what we use for statistics and plotting. A `data.frame` is similar to a matrix in that it's a collection of vectors of of the **same length** and each vector represents a column. However, in a dataframe **each vector can be of a different data type** (e.g., characters, integers, factors). \n\n\n\ndataframe\n\n\nA data frame is the most common way of storing data in R, and if used systematically makes data analysis easier.\nWe can create a dataframe by bringing vectors together to form the columns. We do this using the data.frame() function, and giving the function the different vectors we would like to bind together. This function will only work for vectors of the same length.\ndf &lt;- data.frame(species, glengths)\nNote that you can view your data.frame object by clicking on its name in the Environment window.\n\n\nLists\nLists are a data structure in R that can be perhaps a bit daunting at first, but soon become amazingly useful. A list is a data structure that can hold any number of any types of other data structures.\n\n\n\nlist\n\n\nIf you have variables of different data structures you wish to combine, you can put all of those into one list object by using the list() function and placing all the items you wish to combine within parentheses:\nlist1 &lt;- list(species, df, number)\nPrint out the list to screen to take a look at the components:\nlist1\n    \n[[1]]\n[1] \"ecoli\" \"human\" \"corn\" \n\n[[2]]\n  species glengths\n1   ecoli      4.6\n2   human   3000.0\n3    corn  50000.0\n\n[[3]]\n[1] 5\nThere are three components corresponding to the three different variables we passed in, and what you see is that structure of each is retained.\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\n\nThe materials used in this lesson were derived from work that is Copyright © Data Carpentry (http://datacarpentry.org/). All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0)."
  },
  {
    "objectID": "get-started/3-syntax.html#data-types",
    "href": "get-started/3-syntax.html#data-types",
    "title": "R Syntax and Data Structures",
    "section": "Data Types",
    "text": "Data Types\nVariables can contain values of specific types within R. The six data types that R uses include:\n\n\"numeric\" for any numerical value, including whole numbers and decimals. This is the most common data type for performing mathematical operations.\n\"character\" for text values, denoted by using quotes (““) around value. For instance, while 5 is a numeric value, if you were to put quotation marks around it, it would turn into a character value, and you could no longer use it for mathematical operations. Single or double quotes both work, as long as the same type is used at the beginning and end of the character value.\n\"integer\" for whole numbers (e.g., 2L, the L indicates to R that it’s an integer). It behaves similar to the numeric data type for most tasks or functions; however, it takes up less storage space than numeric data, so often tools will output integers if the data is known to be comprised of whole numbers. Just know that integers behave similarly to numeric values. If you wanted to create your own, you could do so by providing the whole number, followed by an upper-case L.\n\"logical\" for TRUE and FALSE (the Boolean data type). The logical data type can be specified using four values, TRUE in all capital letters, FALSE in all capital letters, a single capital T or a single capital F.\n\"complex\" to represent complex numbers with real and imaginary parts (e.g., 1+4i) and that’s all we’re going to say about them\n\"raw\" that we won’t discuss further\n\nThe table below provides examples of each of the commonly used data types:\n\n\n\nData Type\nExamples\n\n\n\n\nNumeric:\n1, 1.5, 20, pi\n\n\nCharacter:\n“anytext”, “5”, “TRUE”\n\n\nInteger:\n2L, 500L, -17L\n\n\nLogical:\nTRUE, FALSE, T, F\n\n\n\nThe type of data will determine what you can do with it. For example, if you want to perform mathematical operations, then your data type cannot be character or logical. Whereas if you want to search for a word or pattern in your data, then you data should be of the character data type. The task or function being performed on the data will determine what type of data can be used."
  },
  {
    "objectID": "get-started/3-syntax.html#data-structures",
    "href": "get-started/3-syntax.html#data-structures",
    "title": "R Syntax and Data Structures",
    "section": "Data Structures",
    "text": "Data Structures\nWe know that variables are like buckets, and so far we have seen that bucket filled with a single value. Even when number was created, the result of the mathematical operation was a single value. Variables can store more than just a single value, they can store a multitude of different data structures. These include, but are not limited to, vectors (c), factors (factor), matrices (matrix), data frames (data.frame) and lists (list).\n\nVectors\nA vector is the most common and basic data structure in R, and is pretty much the workhorse of R. It’s basically just a collection of values, mainly either numbers,\n\n\n\nnumeric vector\n\n\nor characters,\n\n\n\ncharacter vector\n\n\nor logical values,\n\n\n\nlogical vector\n\n\nNote that all values in a vector must be of the same data type. If you try to create a vector with more than a single data type, R will try to coerce it into a single data type.\nFor example, if you were to try to create the following vector:\n\n\n\nmixed vector\n\n\nR will coerce it into:\n\nThe analogy for a vector is that your bucket now has different compartments; these compartments in a vector are called elements.\nEach element contains a single value, and there is no limit to how many elements you can have. A vector is assigned to a single variable, because regardless of how many elements it contains, in the end it is still a single entity (bucket).\nLet’s create a vector of genome lengths and assign it to a variable called glengths.\nEach element of this vector contains a single numeric value, and three values will be combined together into a vector using c() (the combine function). All of the values are put within the parentheses and separated with a comma.\n# Create a numeric vector and store the vector as a variable called 'glengths'\nglengths &lt;- c(4.6, 3000, 50000)\nglengths\nNote your environment shows the glengths variable is numeric (num) and tells you the glengths vector starts at element 1 and ends at element 3 (i.e. your vector contains 3 values) as denoted by the [1:3].\nA vector can also contain characters. Create another vector called species with three elements, where each element corresponds with the genome sizes vector (in Mb).\n# Create a character vector and store the vector as a variable called 'species'\nspecies &lt;- c(\"ecoli\", \"human\", \"corn\")\nspecies\nWhat do you think would happen if we forgot to put quotations around one of the values? Let’s test it out with corn.\n# Forget to put quotes around corn\nspecies &lt;- c(\"ecoli\", \"human\", corn)\nNote that RStudio is quite helpful in color-coding the various data types. We can see that our numeric values are blue, the character values are green, and if we forget to surround corn with quotes, it’s black. What does this mean? Let’s try to run this code.\nWhen we try to run this code we get an error specifying that object ‘corn’ is not found. What this means is that R is looking for an object or variable in my Environment called ‘corn’, and when it doesn’t find it, it returns an error. If we had a character vector called ‘corn’ in our Environment, then it would combine the contents of the ‘corn’ vector with the values “ecoli” and “human”.\nSince we only want to add the value “corn” to our vector, we need to re-run the code with the quotation marks surrounding corn. A quick way to add quotes to both ends of a word in RStudio is to highlight the word, then press the quote key.\n# Create a character vector and store the vector as a variable called 'species'\nspecies &lt;- c(\"ecoli\", \"human\", \"corn\")\n\nExercise\nTry to create a vector of numeric and character values by combining the two vectors that we just created (glengths and species). Assign this combined vector to a new variable called combined. Hint: you will need to use the combine c() function to do this. Print the combined vector in the console, what looks different compared to the original vectors?\n\n\n\nFactors\nA factor is a special type of vector that is used to store categorical data. Each unique category is referred to as a factor level (i.e. category = level). Factors are built on top of integer vectors such that each factor level is assigned an integer value, creating value-label pairs.\nFor instance, if we have four animals and the first animal is female, the second and third are male, and the fourth is female, we could create a factor that appears like a vector, but has integer values stored under-the-hood. The integer value assigned is a one for females and a two for males. The numbers are assigned in alphabetical order, so because the f- in females comes before the m- in males in the alphabet, females get assigned a one and males a two. In later lessons we will show you how you could change these assignments.\n\n\n\nfactors\n\n\nLet’s create a factor vector and explore a bit more. We’ll start by creating a character vector describing three different levels of expression. Perhaps the first value represents expression in mouse1, the second value represents expression in mouse2, and so on and so forth:\n# Create a character vector and store the vector as a variable called 'expression'\nexpression &lt;- c(\"low\", \"high\", \"medium\", \"high\", \"low\", \"medium\", \"high\")\nNow we can convert this character vector into a factor using the factor() function:\n# Turn 'expression' vector into a factor\nexpression &lt;- factor(expression)\nSo, what exactly happened when we applied the factor() function?\n\n\n\nfactor_new\n\n\nThe expression vector is categorical, in that all the values in the vector belong to a set of categories; in this case, the categories are low, medium, and high. By turning the expression vector into a factor, the categories are assigned integers alphabetically, with high=1, low=2, medium=3. This in effect assigns the different factor levels. You can view the newly created factor variable and the levels in the Environment window.\n\n\n\nFactor variables in environment\n\n\nSo now that we have an idea of what factors are, when would you ever want to use them?\nFactors are extremely valuable for many operations often performed in R. For instance, factors can give order to values with no intrinsic order. In the previous ‘expression’ vector, if I wanted the low category to be less than the medium category, then we could do this using factors. Also, factors are necessary for many statistical methods. For example, descriptive statistics can be obtained for character vectors if you have the categorical information stored as a factor. Also, if you want to denote which category is your base level for a statistical comparison, then you would need to have your category variable stored as a factor with the base level assigned to 1. Anytime that it is helpful to have the categories thought of as groups in an analysis, the factor function makes this possible. For instance, if you want to color your plots by treatment type, then you would need the treatment variable to be a factor.\n\nExercises\nLet’s say that in our experimental analyses, we are working with three different sets of cells: normal, cells knocked out for geneA (a very exciting gene), and cells overexpressing geneA. We have three replicates for each celltype.\n\nCreate a vector named samplegroup with nine elements: 3 control (“CTL”) values, 3 knock-out (“KO”) values, and 3 over-expressing (“OE”) values.\nTurn samplegroup into a factor data structure.\n\n\n\n\nMatrix\nA matrix in R is a collection of vectors of same length and identical datatype. Vectors can be combined as columns in the matrix or by row, to create a 2-dimensional structure.\n\n\n\nmatrix\n\n\nMatrices are used commonly as part of the mathematical machinery of statistics. They are usually of numeric datatype and used in computational algorithms to serve as a checkpoint. For example, if input data is not of identical data type (numeric, character, etc.), the matrix() function will throw an error and stop any downstream code execution.\n\n\nData Frame\nA data.frame is the de facto data structure for most tabular data and what we use for statistics and plotting. A data.frame is similar to a matrix in that it’s a collection of vectors of the same length and each vector represents a column. However, in a dataframe each vector can be of a different data type (e.g., characters, integers, factors). In the data frame pictured below, the first column is character, the second column is numeric, the third is character, and the fourth is logical.\n\n\n\ndataframe\n\n\nA data frame is the most common way of storing data in R, and if used systematically makes data analysis easier.\nWe can create a dataframe by bringing vectors together to form the columns. We do this using the data.frame() function, and giving the function the different vectors we would like to bind together. This function will only work for vectors of the same length.\n# Create a data frame and store it as a variable called 'df'\ndf &lt;- data.frame(species, glengths)\nWe can see that a new variable called df has been created in our Environment within a new section called Data. In the Environment, it specifies that df has 3 observations of 2 variables. What does that mean? In R, rows always come first, so it means that df has 3 rows and 2 columns. We can get additional information if we click on the blue circle with the white triangle in the middle next to df. It will display information about each of the columns in the data frame, giving information about what the data type is of each of the columns and the first few values of those columns.\nAnother handy feature in RStudio is that if we hover the cursor over the variable name in the Environment, df, it will turn into a pointing finger. If you click on df, it will open the data frame as it’s own tab next to the script editor. We can explore the table interactively within this window. To close, just click on the X on the tab.\nAs with any variable, we can print the values stored inside to the console if we type the variable’s name and run.\ndf\n\nExercise\nCreate a data frame called favorite_books with the following vectors as columns:\ntitles &lt;- c(\"Catch-22\", \"Pride and Prejudice\", \"Nineteen Eighty Four\")\npages &lt;- c(453, 432, 328)\n\n\n\nLists\nLists are a data structure in R that can be perhaps a bit daunting at first, but soon become amazingly useful. A list is a data structure that can hold any number of any types of other data structures.\n\n\n\nlist\n\n\nIf you have variables of different data structures you wish to combine, you can put all of those into one list object by using the list() function and placing all the items you wish to combine within parentheses:\nlist1 &lt;- list(species, df, number)\nWe see list1 appear within the Data section of our environment as a list of 3 components or variables. If we click on the blue circle with a triangle in the middle, it’s not quite as interpretable as it was for data frames.\nEssentially, each component is preceded by a colon. The first colon give the species vector, the second colon precedes the df data frame, with the dollar signs indicating the different columns, the last colon gives the single value, number.\nIf I click on list1, it opens a tab where you can explore the contents a bit more, but it’s still not super intuitive. The easiest way to view small lists is to print to the console.\nLet’s type list1 and print to the console by running it.\nlist1\n    \n[[1]]\n[1] \"ecoli\" \"human\" \"corn\" \n\n[[2]]\n  species glengths\n1   ecoli      4.6\n2   human   3000.0\n3    corn  50000.0\n\n[[3]]\n[1] 5\nThere are three components corresponding to the three different variables we passed in, and what you see is that structure of each is retained. Each component of a list is referenced based on the number position. We will talk more about how to inspect and manipulate components of lists in later lessons.\n\nExercise\nCreate a list called list2 containing species, glengths, and number.\n\nNow that we know what lists are, why would we ever want to use them? When getting started with R, you will most likely encounter lists with different tools or functions that you use. Oftentimes a tool will need a list as input, so that all the information needed to run the tool is present in a single variable. Sometimes a tool will output a list when working through an analysis. Knowing how to work with them and extract necessary information will be critically important.\nAs you become more comfortable with R, you will find yourself using lists more often. One common use of lists is to make iterative processes more efficient. For example, let’s say you had multiple data frames containing the same weather information from different cities throughout North America. You wanted to perform the same task on each of the data frames, but that would take a long time to do individually. Instead you could create a list where each data frame is a component of the list. Then, you could perform the task on the list instead, which would be applied to each of the components.\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\n\nThe materials used in this lesson are adapted from work that is Copyright © Data Carpentry (http://datacarpentry.org/). All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0)."
  },
  {
    "objectID": "get-started/4-functions.html",
    "href": "get-started/4-functions.html",
    "title": "Functions in R",
    "section": "",
    "text": "Approximate time: 30 min"
  },
  {
    "objectID": "get-started/4-functions.html#learning-objectives",
    "href": "get-started/4-functions.html#learning-objectives",
    "title": "Functions in R",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe and utilize functions in R.\nModify default behavior of a function using arguments.\nIdentify R-specific sources of obtaining more information about functions.\nDemonstrate how to create user-defined functions in R"
  },
  {
    "objectID": "get-started/4-functions.html#functions-and-their-arguments",
    "href": "get-started/4-functions.html#functions-and-their-arguments",
    "title": "Functions in R",
    "section": "Functions and their arguments",
    "text": "Functions and their arguments\n\nWhat are functions?\nA key feature of R is functions. Functions are “self contained” modules of code that accomplish a specific task. Functions usually take in some sort of data structure (value, vector, dataframe etc.), process it, and return a result.\nThe general usage for a function is the name of the function followed by parentheses:\nfunction_name(input)\nThe input(s) are called arguments, which can include:\n\nthe physical object (any data structure) on which the function carries out a task\nspecifications that alter the way the function operates (e.g. options)\n\nNot all functions take arguments, for example:\ngetwd()\nHowever, most functions can take several arguments. If you don’t specify a required argument when calling the function, you will either receive an error or the function will fall back on using a default.\nThe defaults represent standard values that the author of the function specified as being “good enough in standard cases”. An example would be what symbol to use in a plot. However, if you want something specific, simply change the argument yourself with a value of your choice.\n\n\nBasic functions\nWe have already used a few examples of basic functions in the previous lessons i.e getwd(), c(), and factor(). These functions are available as part of R’s built in capabilities, and we will explore a few more of these base functions below.\nLet’s revisit a function that we have used previously to combine data c() into vectors. The arguments it takes is a collection of numbers, characters or strings (separated by a comma). The c() function performs the task of combining the numbers or characters into a single vector. You can also use the function to add elements to an existing vector:\nglengths &lt;- c(glengths, 90) # adding at the end \nglengths &lt;- c(30, glengths) # adding at the beginning\nWhat happens here is that we take the original vector glengths (containing three elements), and we are adding another item to either end. We can do this over and over again to build a vector or a dataset.\nSince R is used for statistical computing, many of the base functions involve mathematical operations. One example would be the function sqrt(). The input/argument must be a number, and the output is the square root of that number. Let’s try finding the square root of 81:\nsqrt(81)\nNow what would happen if we called the function (e.g. ran the function), on a vector of values instead of a single value?\nsqrt(glengths)\nIn this case the task was performed on each individual value of the vector glengths and the respective results were displayed.\nLet’s try another function, this time using one that we can change some of the options (arguments that change the behavior of the function), for example round:\nround(3.14159)\nWe can see that we get 3. That’s because the default is to round to the nearest whole number. What if we want a different number of significant digits? Let’s first learn how to find available arguments for a function.\n\n\nSeeking help on arguments for functions\nThe best way of finding out this information is to use the ? followed by the name of the function. Doing this will open up the help manual in the bottom right panel of RStudio that will provide a description of the function, usage, arguments, details, and examples:\n?round\nAlternatively, if you are familiar with the function but just need to remind yourself of the names of the arguments, you can use:\nargs(round)\nEven more useful is the example() function. This will allow you to run the examples section from the Online Help to see exactly how it works when executing the commands. Let’s try that for round():\nexample(\"round\")\nIn our example, we can change the number of digits returned by adding an argument. We can type digits=2 or however many we may want:\nround(3.14159, digits=2)\n\nNOTE: If you provide the arguments in the exact same order as they are defined (in the help manual) you don’t have to name them:\nround(3.14159, 2)\nHowever, it’s usually not recommended practice because it involves a lot of memorization. In addition, it makes your code difficult to read for your future self and others, especially if your code includes functions that are not commonly used. (It’s however OK to not include the names of the arguments for basic functions like mean, min, etc…). Another advantage of naming arguments, is that the order doesn’t matter. This is useful when a function has many arguments.\n\n\nExercise\n\nLet’s use base R function to calculate mean value of the glengths vector. You might need to search online to find what function can perform this task.\nCreate a new vector test &lt;- c(1, NA, 2, 3, NA, 4). Use the same base R function from exercise 1 (with addition of proper argument), and calculate mean value of the test vector. The output should be 2.5. &gt; NOTE: In R, missing values are represented by the symbol NA (not available). It’s a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. There are ways to ignore NA during statistical calculation, or to remove NA from the vector. If you want more information related to missing data or NA you can go to this page (please note that there are many advanced concepts on that page that have not been covered in class).\nAnother commonly used base function is sort(). Use this function to sort the glengths vector in descending order.\n\n\n\n\nUser-defined Functions\nOne of the great strengths of R is the user’s ability to add functions. Sometimes there is a small task (or series of tasks) you need done and you find yourself having to repeat it multiple times. In these types of situations, it can be helpful to create your own custom function. The structure of a function is given below:\nname_of_function &lt;- function(argument1, argument2) {\n    statements or code that does something\n    return(something)\n}\n\nFirst you give your function a name.\nThen you assign value to it, where the value is the function.\n\nWhen defining the function you will want to provide the list of arguments required (inputs and/or options to modify behaviour of the function), and wrapped between curly brackets place the tasks that are being executed on/using those arguments. The argument(s) can be any type of object (like a scalar, a matrix, a dataframe, a vector, a logical, etc), and it’s not necessary to define what it is in any way.\nFinally, you can “return” the value of the object from the function, meaning pass the value of it into the global environment. The important idea behind functions is that objects that are created within the function are local to the environment of the function – they don’t exist outside of the function.\nLet’s try creating a simple example function. This function will take in a numeric value as input, and return the squared value.\nsquare_it &lt;- function(x) {\n    square &lt;- x * x\n    return(square)\n}\nOnce you run the code, you should see a function named square_it in the Environment panel (located at the top right of Rstudio interface). Now, we can use this function as any other base R functions. We type out the name of the function, and inside the parentheses we provide a numeric value x:\nsquare_it(5)\nPretty simple, right? In this case, we only had one line of code that was run, but in theory you could have many lines of code to get obtain the final results that you want to “return” to the user.\n\nDo I always have to return() something at the end of the function?\nIn the example above, we created a new variable called square inside the function, and then return the value of square. If you don’t use return(), by default R will return the value of the last line of code inside that function. That is to say, the following function will also work.\nsquare_it &lt;- function(x) {\n   x * x\n}\nHowever, we recommend always using return at the end of a function as the best practice.\n\nWe have only scratched the surface here when it comes to creating functions! We will revisit this in later lessons, but if interested you can also find more detailed information on this R-bloggers site, which is where we adapted this example from.\n\nExercise\n\nWrite a function called multiply_it, which takes two inputs: a numeric value x, and a numeric value y. The function will return the product of these two numeric values, which is x * y. For example, multiply_it(x=4, y=6) will return output 24.\n\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\n\nThe materials used in this lesson are adapted from work that is Copyright © Data Carpentry (http://datacarpentry.org/). All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0)."
  },
  {
    "objectID": "get-started/5-data.html",
    "href": "get-started/5-data.html",
    "title": "Reading in and inspecting data",
    "section": "",
    "text": "Demonstrate how to read existing data into R\nUtilize base R functions to inspect data structures"
  },
  {
    "objectID": "get-started/5-data.html#learning-objectives",
    "href": "get-started/5-data.html#learning-objectives",
    "title": "Reading in and inspecting data",
    "section": "",
    "text": "Demonstrate how to read existing data into R\nUtilize base R functions to inspect data structures"
  },
  {
    "objectID": "get-started/5-data.html#reading-data-into-r",
    "href": "get-started/5-data.html#reading-data-into-r",
    "title": "Reading in and inspecting data",
    "section": "Reading data into R",
    "text": "Reading data into R\n\nThe basics\nRegardless of the specific analysis in R we are performing, we usually need to bring data in for any analysis being done in R, so learning how to read in data is a crucial component of learning to use R.\nMany functions exist to read data in, and the function in R you use will depend on the file format being read in. Below we have a table with some examples of functions that can be used for importing some common text data types (plain text).\n\n\n\n\n\n\n\n\n\nData type\nExtension\nFunction\nPackage\n\n\n\n\nComma separated values\ncsv\nread.csv()\nutils (default)\n\n\n\n\nread_csv()\nreadr (tidyverse)\n\n\nTab separated values\ntsv\nread_tsv()\nreadr\n\n\nOther delimited formats\ntxt\nread.table()\nutils\n\n\n\n\nread_table()\nreadr\n\n\n\n\nread_delim()\nreadr\n\n\n\nFor example, if we have text file where the columns are separated by commas (comma-separated values or comma-delimited), you could use the function read.csv. However, if the data are separated by a different delimiter in a text file (e.g. “:”, “;”, ” “,”), you could use the generic read.table function and specify the delimiter (sep = \" \") as an argument in the function.\n\nNote: The \"\\t\" delimiter is shorthand for tab.\n\nIn the above table we refer to base R functions as being contained in the “utils” package. In addition to base R functions, we have also listed functions from some other packages that can be used to import data, specifically the “readr” package that installs when you install the “tidyverse” suite of packages.\nIn addition to plain text files, you can also import data from other statistical analysis packages and Excel using functions from different packages.\n\n\n\n\n\n\n\n\n\nData type\nExtension\nFunction\nPackage\n\n\n\n\nStata version 13-14\ndta\nreaddta()\nhaven\n\n\nStata version 7-12\ndta\nread.dta()\nforeign\n\n\nSPSS\nsav\nread.spss()\nforeign\n\n\nSAS\nsas7bdat\nread.sas7bdat()\nsas7bdat\n\n\nExcel\nxlsx, xls\nread_excel()\nreadxl (tidyverse)\n\n\n\nNote, that these lists are not comprehensive, and may other functions exist for importing data. Once you have been using R for a bit, maybe you will have a preference for which functions you prefer to use for which data type.\n\n\nMetadata\nWhen working with large datasets, you will very likely be working with “metadata” file which contains the information about each sample in your dataset.\n\nThe metadata is very important information and we encourage you to think about creating a document with as much metadata you can record before you bring the data into R. Here is some additional reading on metadata from the HMS Data Management Working Group.\n\n\nThe read.csv() function\nLet’s bring in the metadata file we downloaded earlier (mouse_exp_design.csv or mouse_exp_design.txt) using the read.csv function.\nFirst, check the arguments for the function using the ? to ensure that you are entering all the information appropriately:\n?read.csv\n\nThe first thing you will notice is that you’ve pulled up the documentation for read.table(), this is because that is the parent function and all the other functions are in the same family.\nThe next item on the documentation page is the function Description, which specifies that the output of this set of functions is going to be a data frame - “Reads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.”\nIn usage, all of the arguments listed for read.table() are the default values for all of the family members unless otherwise specified for a given function. Let’s take a look at 2 examples: 1. The separator - * in the case of read.table() it is sep = \"\" (space or tab) * whereas for read.csv() it is sep = \",\" (a comma). 2. The header - This argument refers to the column headers that may (TRUE) or may not (FALSE) exist in the plain text file you are reading in. * in the case of read.table() it is header = FALSE (by default, it assumes you do not have column names) * whereas for read.csv() it is header = TRUE (by default, it assumes that all your columns have names listed).\nThe take-home from the “Usage” section for read.csv() is that it has one mandatory argument, the path to the file and filename in quotations; in our case that is data/mouse_exp_design.csv or data/mouse_exp_design.txt.\n\nThe stringsAsFactors argument\nNote that the read.table {utils} family of functions has an argument called stringsAsFactors, which by default is set to FALSE (you can double check this by searching the Help tab for read.table or running ?read.table in the console).\nIf stringsAsFactors = TRUE, any function in this family of functions will coerce character columns in the data you are reading in to factor columns (i.e., coerce from vector to factor) in the resulting data frame.\nIf you want to maintain the character vector data structure (e.g., for gene names), you will want to make sure that stringsAsFactors = FALSE.\n\n\n\n\nCreate a data frame by reading in the file\nAt this point, please check the extension for the mouse_exp_design file within your data folder. You will have to type it accordingly within the read.csv() function.\n\nread.csv is not fussy about extensions for plain text files, so even though the file we are reading in is a comma-separated value file, it will be read in properly even with a .txt extension.\n\nLet’s read in the mouse_exp_design file and create a new data frame called metadata.\nmetadata &lt;- read.csv(file=\"data/mouse_exp_design.csv\")\n\n# OR \n# metadata &lt;- read.csv(file=\"data/mouse_exp_design.txt\")\n\nNOTE: RStudio supports the automatic completion of code using the Tab key. This is especially helpful for when reading in files to ensure the correct file path. The tab completion feature also provides a shortcut to listing objects, and inline help for functions. Tab completion is your friend! We encourage you to use it whenever possible.\n\n\n\nClick here to see how to import data using the Import Dataset button\n\nYou can also use the Import Dataset button in your Environment pane to import data. This option is not as appealing because it can lack reproducibility if not documented properly, but it can be helpful when getting started. In order to use the Import Dataset:\n\n\nLeft-click the Import Dataset button in the Environment pane\n\n\nLeft-click From Text (base…)\n\n\nNavigate to the file you would like to import and select Open\n\n\nType the name you would like the imported object to be called in the Name textbox.\n\n\nSelect the delimiter that your file is using in the Separator dropdown menu\n\n\nLeft-click Import\n\n\nThese steps are summarized in the GIF below:  Now the dataset has been imported into your environment.\n\nNote: If you are going to use this method, it could impact the reproducibility of your work, because the steps to do that import are not recorded anywhere. If you are going to use this method of importing data, it is STRONGLY RECOMMENDED that you copy the command that read the dataset in and is present in the console to an Rscript file. In the future, you can run that line of code from the Rscript file to recreate the data object.\n\n\n\nGo to your Global environment and click on the name of the data frame you just created.\n\nWhen you do this the metadata table will pop up on the top left hand corner of RStudio, right next to the R script.\n\nYou should see a subtle coloring (blue-gray) of the first row and first column, the rest of the table will have a white background. This is because your first row and first columns have different properties than the rest of the table, they are the names of the rows and columns respectively.\n\nEarlier we noted that the file we just read in had column names (first row of values) and how read.csv() deals with “headers”. In addition to column headers, read.csv() also assumes that the first column contains the row names. Not all functions in the read.table() family of functions will do this and depending on which one you use, you may have to specify an additional argument to properly assign the row names and column names.\n\nRow names and column names are really handy when subsetting data structures and they are also helpful to identify samples or genes. We almost always use them with data frames.\n\n\nExercise 1\n\nDownload this tab-delimited .txt file and save it in your project’s data folder.\nRead it in to R using read.table() with the approriate arguments and store it as the variable proj_summary. To figure out the appropriate arguments to use with read.table(), keep the following in mind:\n\nall the columns in the input text file have column name/headers\nyou want the first column of the text file to be used as row names (hint: look up the input for the row.names = argument in read.table())\n\nDisplay the contents of proj_summary in your console"
  },
  {
    "objectID": "get-started/5-data.html#inspecting-data-structures",
    "href": "get-started/5-data.html#inspecting-data-structures",
    "title": "Reading in and inspecting data",
    "section": "Inspecting data structures",
    "text": "Inspecting data structures\nThere are a wide selection of base functions in R that are useful for inspecting your data and summarizing it. Let’s use the metadata file that we created to test out data inspection functions.\nTake a look at the dataframe by typing out the variable name metadata and pressing return; the variable contains information describing the samples in our study. Each row holds information for a single sample, and the columns contain categorical information about the sample genotype(WT or KO), celltype (typeA or typeB), and replicate number (1,2, or 3).\nmetadata\n\ngenotype celltype replicate\nsample1        Wt    typeA      1\nsample2        Wt    typeA      2\nsample3        Wt    typeA      3\nsample4        KO    typeA      1\nsample5        KO    typeA      2\nsample6        KO    typeA      3\nsample7        Wt    typeB      1\nsample8        Wt    typeB      2\nsample9        Wt    typeB      3\nsample10       KO    typeB      1\nsample11       KO    typeB      2\nsample12       KO    typeB      3\nSuppose we had a larger file, we might not want to display all the contents in the console. Instead we could check the top (the first 6 lines) of this data.frame using the function head():\nhead(metadata)\n\nList of functions for data inspection\nWe already saw how the functions head() and str() (in the releveling section) can be useful to check the content and the structure of a data.frame. Below is a non-exhaustive list of functions to get a sense of the content/structure of data. The list has been divided into functions that work on all types of objects, some that work only on vectors/factors (1 dimensional objects), and others that work on data frames and matrices (2 dimensional objects).\nWe have some exercises below that will allow you to gain more familiarity with these. You will definitely be using some of them in the next few homework sections.\n\nAll data structures - content display:\n\nstr(): compact display of data contents (similar to what you see in the Global environment)\n\nclass(): displays the data type for vectors (e.g. character, numeric, etc.) and data structure for dataframes, matrices, lists\nsummary(): detailed display of the contents of a given object, including descriptive statistics, frequencies\nhead(): prints the first 6 entries (elements for 1-D objects, rows for 2-D objects)\ntail(): prints the last 6 entries (elements for 1-D objects, rows for 2-D objects)\nVector and factor variables:\n\nlength(): returns the number of elements in a vector or factor\n\nDataframe and matrix variables:\n\ndim(): returns dimensions of the dataset (number_of_rows, number_of_columns) [Note, row numbers will always be displayed before column numbers in R]\n\nnrow(): returns the number of rows in the dataset\nncol(): returns the number of columns in the dataset\nrownames(): returns the row names in the dataset\n\ncolnames(): returns the column names in the dataset\n\n\nExercise 2\n\nUse the class() function on glengths and metadata, how does the output differ between the two?\nUse the summary() function on the proj_summary dataframe, what is the median “rRNA_rate”?\nHow long is the samplegroup factor?\nWhat are the dimensions of the proj_summary dataframe?\nWhen you use the rownames() function on metadata, what is the data structure of the output?\n[Optional] How many elements in (how long is) the output of colnames(proj_summary)? Don’t count, but use another function to determine this."
  },
  {
    "objectID": "get-started/5-data.html#section",
    "href": "get-started/5-data.html#section",
    "title": "Reading in and inspecting data",
    "section": "***",
    "text": "***\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\n\nThe materials used in this lesson are adapted from work that is Copyright © Data Carpentry (http://datacarpentry.org/). All Data Carpentry instructional material is made available under the Creative Commons Attribution license (CC BY 4.0)."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html",
    "href": "sessions/week2/2-datawragling.html",
    "title": "Week 2 - Data Wrangling",
    "section": "",
    "text": "Artwork by @allison_horst"
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#prerequisites",
    "href": "sessions/week2/2-datawragling.html#prerequisites",
    "title": "Week 2 - Data Wrangling",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore you begin, ensure you have the following installed:\n\nR: You can download the latest version from the official R website. Instructions for different operating systems (Windows, Mac OS, UNIX/Linux) are available [8]. R must be installed before installing RStudio [9].\nRStudio: Download and install RStudio Desktop from https://www.rstudio.com/ [10]. To open RStudio, locate it in your applications and launch it [11].\ntidyverse package: Install the tidyverse package within R. Open RStudio and in the Console pane, type and run the following command [12]:\ninstall.packages(\"tidyverse\")\n\nThis command needs to be run only the first time you want to use the tidyverse. You can also install packages by navigating to Tools -&gt; Install Packages in RStudio."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#readings",
    "href": "sessions/week2/2-datawragling.html#readings",
    "title": "Week 2 - Data Wrangling",
    "section": "Readings",
    "text": "Readings\n\n Check chapters 1 to 3 of the e-book Tidyverse Skills for Data Science\n Data tidying with tidyr :: Cheatsheet\n Data transformation with dplyr :: Cheatsheet"
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#learning-objectives",
    "href": "sessions/week2/2-datawragling.html#learning-objectives",
    "title": "Week 2 - Data Wrangling",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDemonstrate how to subset, merge, and create new datasets from existing data structures in R.\nPerform basic data wrangling with functions in the Tidyverse package."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#tidyverse-basics",
    "href": "sessions/week2/2-datawragling.html#tidyverse-basics",
    "title": "Week 2 - Data Wrangling",
    "section": "Tidyverse basics",
    "text": "Tidyverse basics\nThe Tidyverse suite of packages introduces users to a set of data structures, functions and operators to make working with data more intuitive, but is slightly different from the way we do things in base R. Two important new concepts we will focus on are pipes and tibbles.\nBefore we get started with pipes or tibbles, let’s load the library:\nlibrary(tidyverse)\n\nPipes\nStringing together commands in R can be quite daunting. Also, trying to understand code that has many nested functions can be confusing.\nTo make R code more human readable, the Tidyverse tools use the pipe, %&gt;%, which was acquired from the magrittr package and is now part of the dplyr package that is installed automatically with Tidyverse. The pipe allows the output of a previous command to be used as input to another command instead of using nested functions.\n\nNOTE: Shortcut to write the pipe is shift + command/ctrl + M\n\nAn example of using the pipe to run multiple commands:\n## A single command\nsqrt(83)\n\n## Base R method of running more than one command\nround(sqrt(83), digits = 2)\n\n## Running more than one command with piping\nsqrt(83) %&gt;% round(digits = 2)\nThe pipe represents a much easier way of writing and deciphering R code, and so we will be taking advantage of it, when possible, as we work through the remaining lesson.\n\nExercises\n\nCreate a vector of random numbers using the code below:\nrandom_numbers &lt;- c(81, 90, 65, 43, 71, 29)\nUse the pipe (%&gt;%) to perform two steps in a single line:\n\nTake the mean of random_numbers using the mean() function.\nRound the output to three digits using the round() function.\n\n\n\n\n\nTibbles\nA core component of the tidyverse is the tibble. Tibbles are a modern rework of the standard data.frame, with some internal improvements to make code more reliable. They are data frames, but do not follow all of the same rules. For example, tibbles can have numbers/symbols for column names, which is not normally allowed in base R.\nImportant: tidyverse is very opininated about row names. These packages insist that all column data (e.g. data.frame) be treated equally, and that special designation of a column as rownames should be deprecated. Tibble provides simple utility functions to handle rownames: rownames_to_column() and column_to_rownames().\nTibbles can be created directly using the tibble() function or data frames can be converted into tibbles using as_tibble(name_of_df).\n\nNOTE: The function as_tibble() will ignore row names, so if a column representing the row names is needed, then the function rownames_to_column(name_of_df) should be run prior to turning the data.frame into a tibble. Also, as_tibble() will not coerce character vectors to factors by default."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#experimental-data",
    "href": "sessions/week2/2-datawragling.html#experimental-data",
    "title": "Week 2 - Data Wrangling",
    "section": "Experimental data",
    "text": "Experimental data\nWe’re going to explore the Tidyverse suite of tools to wrangle our data to prepare it for visualization. You should have downloaded the file called gprofiler_results_Mov10oe.tsv into your R project’s data folder earlier.\n\nIf you do not have the gprofiler_results_Mov10oe.tsv file in your data folder, you can right click and download it into the data folder using this link.\n\nThe dataset:\n\nRepresents the functional analysis results, including the biological processes, functions, pathways, or conditions that are over-represented in a given list of genes.\nOur gene list was generated by differential gene expression analysis and the genes represent differences between control mice and mice over-expressing a gene involved in RNA splicing.\n\nThe functional analysis that we will focus on involves gene ontology (GO) terms, which:\n\ndescribe the roles of genes and gene products\norganized into three controlled vocabularies/ontologies (domains):\n\nbiological processes (BP)\ncellular components (CC)\nmolecular functions (MF)"
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#analysis-goal-and-workflow",
    "href": "sessions/week2/2-datawragling.html#analysis-goal-and-workflow",
    "title": "Week 2 - Data Wrangling",
    "section": "Analysis goal and workflow",
    "text": "Analysis goal and workflow\nGoal: Visually compare the most significant biological processes (BP) based on the number of associated differentially expressed genes (gene ratios) and significance values by creating the following plot:\n\n\n\ndotplot6\n\n\nTo wrangle our data in preparation for the plotting, we are going to use the Tidyverse suite of tools to wrangle and visualize our data through several steps:\n\nRead in the functional analysis results\nExtract only the GO biological processes (BP) of interest\nSelect only the columns needed for visualization\nOrder by significance (p-adjusted values)\nRename columns to be more intuitive\nCreate additional metrics for plotting (e.g. gene ratios)\nPlot results"
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#tidyverse-tools",
    "href": "sessions/week2/2-datawragling.html#tidyverse-tools",
    "title": "Week 2 - Data Wrangling",
    "section": "Tidyverse tools",
    "text": "Tidyverse tools\nWhile all of the tools in the Tidyverse suite are deserving of being explored in more depth, we are going to investigate more deeply the reading (readr), wrangling (dplyr), and plotting (ggplot2) tools."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#read-in-the-functional-analysis-results",
    "href": "sessions/week2/2-datawragling.html#read-in-the-functional-analysis-results",
    "title": "Week 2 - Data Wrangling",
    "section": "1. Read in the functional analysis results",
    "text": "1. Read in the functional analysis results\nWhile the base R packages have perfectly fine methods for reading in data, the readr and readxl Tidyverse packages offer additional methods for reading in data. Let’s read in our tab-delimited functional analysis results using read_delim():\n# Read in the functional analysis results\nfunctional_GO_results &lt;- read_delim(file = \"data/gprofiler_results_Mov10oe.tsv\", delim = \"\\t\" )\n\n# Take a look at the results\nfunctional_GO_results\n\n\nClick here to see how to do this in base R\n\n\n# Read in the functional analysis results\nfunctional_GO_results &lt;- read.delim(file = \"data/gprofiler_results_Mov10oe.tsv\", sep = \"\\t\" )\n# Take a look at the results\nfunctional_GO_results\n\n\nNotice that the results were automatically read in as a tibble and the output gives the number of rows, columns and the data type for each of the columns.\n\nNOTE: A large number of tidyverse functions will work with both tibbles and dataframes, and the data structure of the output will be identical to the input. However, there are some functions that will return a tibble (without row names), whether or not a tibble or dataframe is provided."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#extract-only-the-go-biological-processes-bp-of-interest",
    "href": "sessions/week2/2-datawragling.html#extract-only-the-go-biological-processes-bp-of-interest",
    "title": "Week 2 - Data Wrangling",
    "section": "2. Extract only the GO biological processes (BP) of interest",
    "text": "2. Extract only the GO biological processes (BP) of interest\nNow that we have our data, we will need to wrangle it into a format ready for plotting. For all of our data wrangling steps we will be using tools from the dplyr package, which is a swiss-army knife for data wrangling of data frames.\nTo extract the biological processes of interest, we only want those rows where the domain is equal to BP, which we can do using the filter() function.\nTo filter rows of a data frame/tibble based on values in different columns, we give a logical expression as input to the filter() function to return those rows for which the expression is TRUE.\nNow let’s return only those rows that have a domain of BP:\n# Return only GO biological processes\nbp_oe &lt;- functional_GO_results %&gt;%\n  filter(domain == \"BP\")\n  \nView(bp_oe)\n\n\nClick here to see how to do this in base R\n\n\n# Return only GO biological processes\nidx &lt;- functional_GO_results$domain == \"BP\"\nbp_oe2 &lt;- functional_GO_results[idx,]\nView(bp_oe)\n\n\nNow we have returned only those rows with a domain of BP. How have the dimensions of our results changed?\n\nExercise:\nWe would like to perform an additional round of filtering to only keep the most specific GO terms.\n\nFor bp_oe, use the filter() function to only keep those rows where the relative.depth is greater than 4.\nSave output to overwrite our bp_oe variable."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#select-only-the-columns-needed-for-visualization",
    "href": "sessions/week2/2-datawragling.html#select-only-the-columns-needed-for-visualization",
    "title": "Week 2 - Data Wrangling",
    "section": "3. Select only the columns needed for visualization",
    "text": "3. Select only the columns needed for visualization\nFor visualization purposes, we are only interested in the columns related to the GO terms, the significance of the terms, and information about the number of genes associated with the terms.\nTo extract columns from a data frame/tibble we can use the select() function. In contrast to base R, we do not need to put the column names in quotes for selection.\n# Selecting columns to keep\nbp_oe &lt;- bp_oe %&gt;%\n  select(term.id, term.name, p.value, query.size, term.size, overlap.size, intersection)\n\nView(bp_oe)\n\n\nClick here to see how to do this in base R\n\n\n# Selecting columns to keep\nbp_oe &lt;- bp_oe[, c(\"term.id\", \"term.name\", \"p.value\", \"query.size\", \"term.size\", \"overlap.size\", \"intersection\")]\nView(bp_oe)\n\n\nThe select() function also allows for negative selection. So we could have alternately removed columns with negative selection. Note that we need to put the column names inside of the combine (c()) function with a - preceding it for this functionality.\n# DO NOT RUN\n# Selecting columns to remove\nbp_oe &lt;- bp_oe %&gt;%\n    select(-c(query.number, significant, recall, precision, subgraph.number, relative.depth, domain))\n\n\nClick here to see how to do this in base R\n\n\n# DO NOT RUN\n# Selecting columns to remove\nidx &lt;- !(colnames(bp_oe) %in% c(\"query.number\", \"significant\", \"recall\", \"precision\", \"subgraph.number\", \"relative.depth\", \"domain\"))\nbp_oe &lt;- bp_oe[, idx]"
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#order-go-processes-by-significance-adjusted-p-values",
    "href": "sessions/week2/2-datawragling.html#order-go-processes-by-significance-adjusted-p-values",
    "title": "Week 2 - Data Wrangling",
    "section": "4. Order GO processes by significance (adjusted p-values)",
    "text": "4. Order GO processes by significance (adjusted p-values)\nNow that we have only the rows and columns of interest, let’s arrange these by significance, which is denoted by the adjusted p-value.\nLet’s sort the rows by adjusted p-value with the arrange() function.\n# Order by adjusted p-value ascending\nbp_oe &lt;- bp_oe %&gt;%\n  arrange(p.value)\n\n\nClick here to see how to do this in base R\n\n\n# Order by adjusted p-value ascending\nidx &lt;- order(bp_oe$p.value)\nbp_oe &lt;- bp_oe[idx,]\n\n\n\nNOTE1: If you wanted to arrange in descending order, then you could have run the following instead:\n# DO NOT RUN\n# Order by adjusted p-value descending\nbp_oe &lt;- bp_oe %&gt;%\n  arrange(desc(p.value))\n\n\nClick here to see how to do this in base R\n\n\n# DO NOT RUN\n# Order by adjusted p-value descending\nidx &lt;- order(bp_oe$p.value, decreasing = TRUE)\nbp_oe &lt;- bp_oe[idx,]\n\n\n\nNOTE2: Ordering variables in ggplot2 is a bit different. This post introduces a few ways of ordering variables in a plot."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#rename-columns-to-be-more-intuitive",
    "href": "sessions/week2/2-datawragling.html#rename-columns-to-be-more-intuitive",
    "title": "Week 2 - Data Wrangling",
    "section": "5. Rename columns to be more intuitive",
    "text": "5. Rename columns to be more intuitive\nWhile not necessary for our visualization, renaming columns more intuitively can help with our understanding of the data using the rename() function. The syntax is new_name = old_name.\nLet’s rename the term.id and term.name columns.\n# Provide better names for columns\nbp_oe &lt;- bp_oe %&gt;% \n  dplyr::rename(GO_id = term.id, \n                GO_term = term.name)\n\n\nClick here to see how to do this in base R\n\n\n# Provide better names for columns\ncolnames(bp_oe)[colnames(bp_oe) == \"term.id\"] &lt;- \"GO_id\"\ncolnames(bp_oe)[colnames(bp_oe) == \"term.name\"] &lt;- \"GO_term\"\n\n\n\nNOTE: In the case of two packages with identical function names, you can use :: with the package name before and the function name after (e.g stats::filter()) to ensure that the correct function is implemented. The :: can also be used to bring in a function from a library without loading it first.\nIn the example above, we wanted to use the rename() function specifically from the dplyr package, and not any of the other packages (or base R) which may have the rename() function.\n\n\nExercise\nRename the intersection column to genes to reflect the fact that these are the DE genes associated with the GO process."
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#create-additional-metrics-for-plotting-e.g.-gene-ratios",
    "href": "sessions/week2/2-datawragling.html#create-additional-metrics-for-plotting-e.g.-gene-ratios",
    "title": "Week 2 - Data Wrangling",
    "section": "6. Create additional metrics for plotting (e.g. gene ratios)",
    "text": "6. Create additional metrics for plotting (e.g. gene ratios)\nFinally, before we plot our data, we need to create a couple of additional metrics. The mutate() function enables you to create a new column from an existing column.\nLet’s generate gene ratios to reflect the number of DE genes associated with each GO process relative to the total number of DE genes.\n# Create gene ratio column based on other columns in dataset\nbp_oe &lt;- bp_oe %&gt;%\n  mutate(gene_ratio = overlap.size / query.size)\n\n\nClick here to see how to do this in base R\n\n\n# Create gene ratio column based on other columns in dataset\nbp_oe &lt;- cbind(bp_oe, gene_ratio = bp_oe$overlap.size / bp_oe$query.size)\n\n\n\nExercise\nCreate a column in bp_oe called term_percent to determine the percent of DE genes associated with the GO term relative to the total number of genes associated with the GO term (overlap.size / term.size)\n\nOur final data for plotting should look like the table below:"
  },
  {
    "objectID": "sessions/week2/2-datawragling.html#next-steps",
    "href": "sessions/week2/2-datawragling.html#next-steps",
    "title": "Week 2 - Data Wrangling",
    "section": "Next steps",
    "text": "Next steps\nNow that we have our results ready for plotting, we can use the ggplot2 package to plot our results. If you are interested, you can follow this lesson and dive into how to use ggplot2 to create the plots with this dataset.\n\nAdditional resources\n\nR for Data Science\nteach the tidyverse\ntidy style guide\n\n\nThis lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  }
]